/ Import necessary modules const express = require('express'); // Import the Express.js framework const app = express(); // Create an instance of the Express application const port = process.env.PORT || 3000; // Define the port number for the server to listen on. Use environment variable PORT if available, otherwise default to 3000. // Middleware (functions that execute during the request-response cycle) // 1. Built-in middleware for parsing JSON request bodies app.use(express.json()); // Parses incoming requests with JSON payloads and makes them available under `req.body` // 2. Built-in middleware for parsing URL-encoded request bodies (e.g., from HTML forms) app.use(express.urlencoded({ extended: true })); // Parses incoming requests with URL-encoded payloads (e.g., from forms) and makes them available under `req.body`. `extended: true` allows for complex objects and arrays in the URL-encoded data. // 3. Example of custom middleware (optional) // Middleware functions have access to the request object (req), the response object (res), and the next middleware function in the applicationâ€™s request-response cycle. // const myMiddleware = (req, res, next) => { // console.log('Middleware executed!'); // // You can modify the request or response here. // // Call `next()` to pass control to the next middleware function or route handler. // next(); // }; // app.use(myMiddleware); // Apply the custom middleware to all routes. Alternatively, it can be applied to specific routes. // Routes (define how the application responds to client requests to specific endpoints) // 1. Root route (GET request to '/') app.get('/', (req, res) => { res.send('Hello World!'); // Send a simple "Hello World!" response to the client }); // 2. Example route with query parameters (GET request to '/greet') app.get('/greet', (req, res) => { const name = req.query.name || 'Guest'; // Extract the 'name' query parameter from the request. If not provided, default to 'Guest'. res.send(`Hello, ${name}!`); // Send a personalized greeting to the client. }); // 3. Example route with URL parameters (GET request to '/users/:userId') app.get('/users/:userId', (req, res) => { const userId = req.params.userId; // Extract the 'userId' parameter from the URL. res.send(`User ID: ${userId}`); // Send the user ID back to the client. }); // 4. Example route for handling POST requests (POST request to '/submit') app.post('/submit', (req, res) => { const data = req.body; // Access the data sent in the request body (parsed by express.json() or express.urlencoded()) console.log('Received data:', data); // Log the received data to the console (for debugging). res.send('Data received successfully!'); // Send a confirmation message back to the client. }); // Start the server and listen for incoming connections app.listen(port, () => { console.log(`Server listening at http://localhost:${port}`); // Log a message to the console when the server starts. }); // Error Handling Middleware (Optional but recommended for robust applications) // This middleware function is called when an error occurs during the processing of a request. // It should be defined after all your route handlers. app.use((err, req, res, next) => { console.error(err.stack); // Log the error stack trace to the console (for debugging) res.status(500).send('Something broke!'); // Send a generic error message to the client. Consider providing more specific error messages in a production environment. }); // Explanation and Best Practices: // 1. **`require('express')`**: Imports the Express.js module. This is essential to create an Express application. // 2. **`const app = express()`**: Creates an instance of the Express application. `app` is the central object for configuring routes, middleware, and other settings. // 3. **`const port = process.env.PORT || 3000`**: Defines the port on which the server will listen. // * `process.env.PORT`: This checks for an environment variable named `PORT`. Environment variables are often used in production deployments to configure the application (e.g., setting the port number). // * `|| 3000`: If the `PORT` environment variable is not set, the server will default to port 3000. // 4. **Middleware**: // * Middleware functions are executed in the order they are added to the application's middleware stack using `app.use()`. // * `express.json()` and `express.urlencoded()` are *essential* for handling data sent in request bodies (e.g., when submitting forms or sending JSON data). Without them, `req.body` will be empty. // * Custom middleware can be used for tasks such as logging, authentication, authorization, and data transformation. // * The `next()` function is crucial. It tells Express to pass control to the next middleware function or route handler in the chain. If you don't call `next()`, the request will hang indefinitely. // 5. **Routes**: // * Routes define how the application responds to specific HTTP requests (e.g., `GET`, `POST`, `PUT`, `DELETE`) to specific URL paths. // * `app.get()`, `app.post()`, `app.put()`, `app.delete()` are the methods used to define routes for different HTTP methods. // * `req.query`: Accesses query parameters (e.g., `/greet?name=John`). // * `req.params`: Accesses URL parameters (e.g., `/users/123`). // * `req.body`: Accesses the data sent in the request body (after it has been parsed by middleware like `express.json()` or `express.urlencoded()`). // * `res.send()`: Sends a response back to the client. It can send plain text, HTML, JSON, or other data. Other methods like `res.json()` (for sending JSON) and `res.sendFile()` (for sending files) are also commonly used. // 6. **Error Handling**: // * An error handling middleware function is a special type of middleware that takes four arguments: `err`, `req`, `res`, and `next`. // * It is defined after all your route handlers. // * When an error occurs during the processing of a request, Express will skip any remaining route handlers and middleware and call the error handling middleware function. // * In a production environment, you should handle errors gracefully and provide informative error messages to the client (without exposing sensitive information). // 7. **Starting the Server** // * `app.listen()`: Starts the Express server and listens for incoming connections on the specified port. // * The callback function passed to `app.listen()` is executed once the server has started successfully. // Important Considerations for Production: // * **Security**: Implement security measures such as authentication, authorization, input validation, and protection against common web vulnerabilities (e.g., Cross-Site Scripting (XSS), Cross-Site Request Forgery (CSRF)). Use HTTPS for secure communication. // * **Logging**: Use a robust logging system to track errors, warnings, and other important events. Consider using a logging library like Winston or Morgan. // * **Environment Variables**: Use environment variables to configure the application for different environments (e.g., development, testing, production). // * **Monitoring**: Monitor the application's performance and health to identify and resolve issues quickly. // * **Deployment**: Use a deployment platform or service to deploy and manage the application in a production environment (e.g., AWS, Heroku, Google Cloud Platform). // * **Database**: Choose a suitable database (e.g., MongoDB, PostgreSQL, MySQL) and integrate it with your application using appropriate database drivers or ORMs. // * **Testing**: Write unit tests and integration tests to ensure that the application is working correctly.